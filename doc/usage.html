<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="author" content="Severin Meyer">
	<link rel="stylesheet" href="style.css">
	<title>Humble Type Instruction Compiler</title>
</head>
<body>

<header>
	<h1>Humble Type Instruction Compiler</h1>
	<nav>
		<ul>
		<li><a href="index.html">Introduction</a>
		<li><a href="instructions.html">Instructions</a>
		<li><a href="blocks.html">Blocks</a>
		<li><a href="example.html">Example</a>
		<li><a href="grammar.html">Grammar</a>
		<li><a href="usage.html" id="current">Usage</a>
		</ul>
	</nav>
</header>

<main>
	<h2>Usage</h2>
	<p>
		The compiler is implemented in Python, so that it can be integrated
		into existing build scripts easily. It is intended to work with both Python 2.7 and 3.
	</p>

<div id="usage">
	<h3>Interface</h3>
	<p>
		Import the <code>htic</code> package,
		then call the appropriate <code>to*</code> function.
	</p>
	<pre><code>import fontforge
import <strong>htic</strong>

font = fontforge.open("myfont.sfd")
<strong>htic.toFontforge</strong>("instructions.hti", font)
font.generate("myfont.ttf")</code></pre>
	<p>
		The following <code>to*</code> functions are available:
	</p>
	<pre><code>htic.toConsole(sourceFile)
htic.toFontforge(sourceFile, font)</code></pre>
</div>

<div id="extension">
	<h3>Extension</h3>
	<p>
		Extending the compiler to support other font types is quite simple.
		Search for the <code>EXTEND</code> keyword in the module code to find the relevant extension points.
	</p>
	<p>
		The main task is to add a custom <code>compiler.to*</code> function.
		Check the existing functions for reference.
		These functions first pass the sourcefile name to <code>parser.parseFile()</code>,
		which returns a <code>Data</code> object. This object contains all parsed
		data in neutral form. Then, the data is written into the output structure.
	</p>
	<p>
		Parsed instruction blocks are represented by <code>Block</code> objects.
		These objects can be converted to the desired format with a <code>Translator</code>.
		Currently, two translator types are available: <code>BinaryTranslator</code>
		converts blocks to binary TrueType code, while <code>StringTranslator</code>
		converts blocks to plain-text strings.
	</p>
	<p>
		To support other instruction formats, add a new <code>Translator</code> type.
		Check the existing translators for reference. They implement the <code>Writer</code>
		interface, which is used by the internal block structure to write out each instruction
		and argument in sequence. A translator accumulates them in
		an appropriate container and then returns the combined value.
	</p>
</div>
</main>

<footer>
	This documentation by
	<a target="_blank" href="http://gitlab.com/u/sev">Severin Meyer</a>
	is licensed under the
	<a target="_blank" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>
</footer>

</body>
</html>
